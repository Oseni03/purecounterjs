{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./purecounter.js","webpack:///./js/purecounter.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","options","this","defaults","start","end","duration","delay","once","decimals","legacy","currency","currencysymbol","separator","separatorsymbol","selector","configOptions","assign","registerEventListeners","elements","document","querySelectorAll","intersectionListenerSupported","intersectObserver","IntersectionObserver","animateElements","forEach","element","observe","window","addEventListener","animateLegacy","e","parseConfig","elementIsInView","observer","elm","target","elementConfig","innerHTML","formatNumber","intersectionRatio","setTimeout","startCounter","config","incrementsPerStep","countMode","currentCount","parseValue","setAttribute","counterWorker","setInterval","nextNum","nextNumber","clearInterval","baseConfig","configValues","filter","attributes","attr","test","replace","toLowerCase","parseInt","number","steps","parseFloat","symbol","limit","Math","abs","Number","toFixed","RegExp","strConfig","minimumFractionDigits","maximumFractionDigits","convertToCurrencySystem","applySeparator","toLocaleString","undefined","data","top","offsetTop","left","offsetLeft","width","offsetWidth","height","offsetHeight","offsetParent","pageYOffset","pageXOffset","innerHeight","innerWidth","IntersectionObserverEntry"],"mappings":"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","file":"/dist/purecounter.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import PureCounter from './js/purecounter';\n\nconst pure = new PureCounter;","export default class PureCounter {\n\tconstructor(options) {\n\t\tthis.defaults = {\n\t\t    start: 0,\n\t\t    end: 100,\n\t\t    duration: 2000,\n\t\t    delay: 10,\n\t\t    once: true,\n\t\t    decimals: 0,\n\t\t    legacy: true,\n\t\t    currency: false,\n\t\t    currencysymbol: false,\n\t\t    separator: false,\n\t\t    separatorsymbol: ',',\n\t\t    selector: '.purecounter'\n\t\t}\n\t\tthis.configOptions = Object.assign({}, this.defaults, options || {});\n\t\tthis.registerEventListeners();\n\t}\n\n\t/** Initial function */\n\tregisterEventListeners() {\n\t\t/** Get all elements with class 'purecounter' */\n\t\tvar elements = document.querySelectorAll(this.configOptions.selector);\n\t\t/** Get browser Intersection Listener Support */\n\t\tvar intersectionSupported = this.intersectionListenerSupported();\n\n\t\t/** Run animateElements base on Intersection Support */\n\t\tif (intersectionSupported) {\n\t\t\tvar intersectObserver = new IntersectionObserver(this.animateElements.bind(this), {\n\t\t\t\t\"root\": null,\n\t\t\t\t\"rootMargin\": '20px',\n\t\t\t\t\"threshold\": 0.5\n\t\t\t});\n\n\t\t\telements.forEach(element => {intersectObserver.observe(element);})\n\t\t} else {\n\t\t\tif (window.addEventListener) {\n\t\t\t\tthis.animateLegacy(elements);\n\n\t\t\t\twindow.addEventListener('scroll', function (e) {\n\t\t\t\t\tthis.animateLegacy(elements);\n\t\t\t\t}, { \"passive\": true });\n\t\t\t}\n\t\t}\n\t}\n\n\t/** This legacy to make Purecounter use very lightweight & fast */\n\tanimateLegacy(elements) {\n\t\telements.forEach(element => {\n\t\t\tvar config = this.parseConfig(element);\n\t\t\tif(config.legacy === true && this.elementIsInView(element)) {\n\t\t\t\tthis.animateElements([element]);\n\t\t\t}\n\t\t})\n\t}\n\n\t/** Main Element Count Animation */\n\tanimateElements(elements, observer) {\n\t\telements.forEach(element => {\n\t\t\tvar elm = element.target || element; // Just make sure which element will be used\n\t\t\tvar elementConfig = this.parseConfig(elm); // Get config value on that element\n\n\t\t\t// If duration is less than or equal zero, just format the 'end' value\n\t\t\tif (elementConfig.duration <= 0) {\n\t\t\t\treturn elm.innerHTML = this.formatNumber(elementConfig.end, elementConfig);\n\t\t\t}\n\n\t\t\tif ((!observer && !this.elementIsInView(element)) || (observer && element.intersectionRatio < 0.5)) {\n\t\t\t\tvar value = elementConfig.start > elementConfig.end ? elementConfig.end : elementConfig.start;\n\t\t\t\treturn elm.innerHTML = this.formatNumber(value, elementConfig);\n\t\t\t}\n\n\t\t\t// If duration is more than 0, then start the counter\n\t\t\tsetTimeout(() => {\n\t\t\t\treturn this.startCounter(elm, elementConfig);\n\t\t\t}, elementConfig.delay);\n\t\t});\n\t}\n\n\t/** This is the the counter method */\n\tstartCounter(element, config) {\n\t\t// First, get the increments step\n\t\tvar incrementsPerStep = (config.end - config.start) / (config.duration / config.delay);\n\t\t// Next, set the counter mode (Increment or Decrement)\n\t\tvar countMode = 'inc';\n\n\t\t// Set mode to 'decrement' and 'increment step' to minus if start is larger than end\n\t\tif (config.start > config.end) {\n\t\t\tcountMode = 'dec';\n\t\t\tincrementsPerStep *= -1;\n\t\t}\n\n\t\t// Next, determine the starting value\n\t\tvar currentCount = this.parseValue(config.start);\n\t\t// And then print it's value to the page\n\t\telement.innerHTML = this.formatNumber(currentCount, config);\n\n\t\t// If the config 'once' is true, then set the 'duration' to 0\n\t\tif(config.once === true){\n\t\t\telement.setAttribute('data-purecounter-duration', 0);\n\t\t}\n\n\t\t// Now, start counting with counterWorker using Interval method based on delay\n\t\tvar counterWorker = setInterval(() => {\n\t\t\t// First, determine the next value base on current value, increment value, and count mode\n\t\t\tvar nextNum = this.nextNumber(currentCount, incrementsPerStep, countMode);\n\t\t\t// Next, print that value to the page\n\t\t\telement.innerHTML = this.formatNumber(nextNum, config);\n\t\t\t// Now set that value to the current value, because it's already printed\n\t\t\tcurrentCount = nextNum;\n\n\t\t\t// If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\n\t\t\tif ((currentCount >= config.end && countMode == 'inc') || (currentCount <= config.end && countMode == 'dec')) {\n\t\t\t\telement.innerHTML = this.formatNumber(config.end, config);\n\t\t\t\tclearInterval(counterWorker);\n\t\t\t}\n\t\t}, config.delay);\n\t}\n\n\t/** This function is to generate the element Config */\n\tparseConfig(element) {\n\t\t// First, we need to declare the base Config\n\t\t// This config will be used if the element doesn't have config\n\t\tvar baseConfig = {...this.configOptions};\n\n\t\t// Next, get all 'data-precounter' attributes value. Store to array\n\t\tvar configValues = [].filter.call(element.attributes, function(attr) {\n\t\t\treturn /^data-purecounter-/.test(attr.name);\n\t\t});\n\n\t\t// Now, we create element config as an empty object\n\t\tvar elementConfig = {};\n\n\t\t// And then, fill the element config based on config values\n\t\tconfigValues.forEach(e => {\n\t\t\tvar name = e.name.replace('data-purecounter-', '').toLowerCase();\n\t\t\tvar value = name == 'duration' ? parseInt(this.parseValue(e.value) * 1000) : this.parseValue(e.value);\n\t\t\telementConfig[name] = value; // We will get an object\n\t\t})\n\n\t\t// Last marge base config with element config and return it as an object\n\t\treturn Object.assign(baseConfig, elementConfig);\n\t}\n\n\t/** This function is to get the next number */\n\tnextNumber(number, steps, mode = 'inc') {\n\t\t// First, get the exact value from the number and step (int or float)\n\t\tnumber = this.parseValue(number);\n\t\tsteps = this.parseValue(steps);\n\n\t\t// Last, get the next number based on current number, increment step, and count mode\n\t\t// Always return it as float\n\t\treturn parseFloat(mode === 'inc' ? (number + steps) : (number - steps));\n\t}\n\n\t/** This function is to convert number into currency format */\n\tconvertToCurrencySystem (number, config) {\n\t\tvar symbol = config.currencysymbol || \"\", // Set the Currency Symbol (if any)\n\t\t\tlimit = config.decimals || 1,  // Set the decimal limit (default is 1)\n\t\t\tnumber = Math.abs(Number(number)); // Get the absolute value of number\n\n\t\t// Set the value\n\t\tvar value = number >= 1.0e+12 ? `${(number / 1.0e+12).toFixed(limit)} T` // Twelve zeros for Trillions\n\t\t\t: number >= 1.0e+9 ? `${(number / 1.0e+9).toFixed(limit)} B` // Nine zeros for Billions\n\t\t\t: number >= 1.0e+6 ? `${(number / 1.0e+6).toFixed(limit)} M`  // Six zeros for Millions\n\t\t\t: number >= 1.0e+3 ? `${(number / 1.0e+12).toFixed(limit)} K` // Three zeros for Thousands\n\t\t\t: number.toFixed(limit); // If less than 1000, print it's value\n\n\t\t// Apply symbol before the value and return it as string\n\t\treturn symbol + value;\n\t}\n\n\t/** This function is to get the last formated number */\n\tapplySeparator(value, config){\n\t\t// If config separator is false, delete all separator\n\t\tif (!config.separator) {\n\t\t\treturn value.replace(new RegExp(/,/gi, 'gi'), '')\n\t\t}\n\n\t\t// If config separator is true, then create separator\n\t\treturn value.replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1,\")\n\t\t\t.replace(new RegExp(/,/gi, 'gi'), config.separatorsymbol)\n\t}\n\n\t/** This function is to get formated number to be printed in the page */\n\tformatNumber(number, config) {\n\t\t// This is the configuration for 'toLocaleString' method\n\t\tvar strConfig = {minimumFractionDigits: config.decimals, maximumFractionDigits: config.decimals};\n\t\t// Set the number if it using currency, then convert. If doesn't, just parse it as float\n\t\tnumber = config.currency ? this.convertToCurrencySystem(number, config) : parseFloat(number);\n\n\t\t// Last, apply the number separator using number as string\n\t\treturn this.applySeparator(number.toLocaleString(undefined, strConfig), config);\n\t}\n\n\t/** This function is to get the parsed value */\n\tparseValue(data) {\n\t\t// If number with dot (.), will be parsed as float\n\t\tif (/^[0-9]+\\.[0-9]+$/.test(data)) {\n\t\t\treturn parseFloat(data);\n\t\t}\n\t\t// If just number, will be parsed as integer\n\t\tif (/^[0-9]+$/.test(data)) {\n\t\t\treturn parseInt(data);\n\t\t}\n\t\t// If it's boolean string, will be parsed as boolean\n\t\tif (/^true|false/i.test(data)) {\n\t\t\treturn /^true/i.test(data);\n\t\t}\n\t\t// Return it's value as default\n\t\treturn data;\n\t}\n\n\t/** This function is to detect the element is in view or not. */\n\telementIsInView(element) {\n\t\tvar top = element.offsetTop;\n\t\tvar left = element.offsetLeft;\n\t\tvar width = element.offsetWidth;\n\t\tvar height = element.offsetHeight;\n\n\t\twhile (element.offsetParent) {\n\t\t\telement = element.offsetParent;\n\t\t\ttop += element.offsetTop;\n\t\t\tleft += element.offsetLeft;\n\t\t}\n\n\t\treturn (\n\t\t\ttop >= window.pageYOffset &&\n\t\t\tleft >= window.pageXOffset &&\n\t\t\t(top + height) <= (window.pageYOffset + window.innerHeight) &&\n\t\t\t(left + width) <= (window.pageXOffset + window.innerWidth)\n\t\t);\n\t}\n\n\t/** Just some condition to check browser Intersection Support */\n\tintersectionListenerSupported() {\n\t\treturn ('IntersectionObserver' in window) &&\n\t\t\t('IntersectionObserverEntry' in window) &&\n\t\t\t('intersectionRatio' in window.IntersectionObserverEntry.prototype);\n\t}\n}\n"],"sourceRoot":""}