{"version":3,"file":"/dist/purecounter.js","mappings":"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","sources":["webpack://PureCounter/webpack/universalModuleDefinition","webpack://PureCounter/./js/purecounter.js","webpack://PureCounter/./purecounter.js","webpack://PureCounter/webpack/bootstrap","webpack://PureCounter/webpack/runtime/define property getters","webpack://PureCounter/webpack/runtime/hasOwnProperty shorthand","webpack://PureCounter/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PureCounter\"] = factory();\n\telse\n\t\troot[\"PureCounter\"] = factory();\n})(self, function() {\nreturn ","export default class PureCounter {\r\n\tconstructor(options = {}) {\r\n\t\t/** Default configurations */\r\n\t\tthis.defaults = {\r\n\t\t    start: 0, \t\t\t\t// Starting number [unit]\r\n\t\t    end: 100, \t\t\t\t// End number [unit]\r\n\t\t    duration: 2000, \t\t// Count duration [milisecond]\r\n\t\t    delay: 10, \t\t\t\t// Count delay [milisecond]\r\n\t\t    once: true, \t\t\t// Counting at once or recount when scroll [boolean]\r\n\t\t\trepeat: false, \t\t\t// Repeat count for certain time [boolean|milisecond]\r\n\t\t    decimals: 0, \t\t\t// Decimal places [unit]\r\n\t\t    legacy: true,\r\n\t\t\tfilesizing: false, \t\t// Is it for filesize?\r\n\t\t    currency: false, \t\t// Is it for currency? Use it for set the symbol too [boolean|char|string]\r\n\t\t    separator: false, \t\t\t// Do you want to use thausands separator? use it for set the symbol too [boolean|char|string]\r\n\t\t\tselector: '.purecounter',\t// HTML query selector for spesific element\r\n\t\t};\r\n\t\t/** Set default configuration based on user input */\r\n\t\tthis.configOptions = this.setOptions(options, this.defaults);\r\n\t\t/** Get all elemenets based on default selector */\r\n\t\tthis.elements = document.querySelectorAll(this.configOptions.selector);\r\n\t\t/** Get browser Intersection Listener Support */\r\n\t\tthis.intersectionSupport = this.intersectionListenerSupported();\r\n\t\t/** Initiate event listened */\r\n\t\tthis.registerEventListeners();\r\n\t}\r\n\r\n\t/** This function is for create and merge configuration */\r\n\tsetOptions(config, baseConfig = {}){\r\n\t\t// Create new Config object;\r\n\t\tlet newConfig = {};\r\n\t\t// Loop config items to set it value into newConfig\r\n\t\tfor(let key in config){\r\n\t\t\t// if baseConfig is set, only accept the baseconfig property\r\n\t\t\tif(baseConfig != {} && !baseConfig.hasOwnProperty(key)) continue;\r\n\t\t\t// let parse the config value\r\n\t\t\tlet val = this.parseValue(config[key]);\r\n\t\t\t// set the newConfig property value\r\n\t\t\tnewConfig[key] = val;\r\n\t\t\t// Exclusive for 'duration' or 'repeat' property, recheck the value\r\n\t\t\t// If it's not a boolean, just set it to milisecond unit\r\n\t\t\tif (key.match(/duration|repeat/)){\r\n\t\t\t\tnewConfig[key] = typeof val != 'boolean' ? val * 1000 : val;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Finally, we can just merge the baseConfig (if any), with newConfig.\r\n\t\treturn Object.assign({}, baseConfig, newConfig);\r\n\t}\r\n\r\n\t/** Initial function */\r\n\tregisterEventListeners() {\r\n\t\t/** Get all elements with class 'purecounter' */\r\n\t\tlet elements = this.elements;\r\n\t\t/** Return if no elements */\r\n\t\tif (elements.length === 0) return;\r\n\r\n\t\t/** Run animateElements base on Intersection Support */\r\n\t\tif (this.intersectionSupport) {\r\n\t\t\tlet intersectObserver = new IntersectionObserver(this.animateElements.bind(this), {\r\n\t\t\t\t\"root\": null,\r\n\t\t\t\t\"rootMargin\": '20px',\r\n\t\t\t\t\"threshold\": 0.5\r\n\t\t\t});\r\n\r\n\t\t\telements.forEach(element => {intersectObserver.observe(element);})\r\n\t\t} else {\r\n\t\t\tif (window.addEventListener) {\r\n\t\t\t\tthis.animateLegacy(elements);\r\n\t\t\t\twindow.addEventListener('scroll', function (e) {\r\n\t\t\t\t\tthis.animateLegacy(elements);\r\n\t\t\t\t}, { \"passive\": true });\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** This legacy to make Purecounter use very lightweight & fast */\r\n\tanimateLegacy(elements) {\r\n\t\telements.forEach(element => {\r\n\t\t\tlet {legacy} = this.parseConfig(element);\r\n\t\t\tif(legacy === true && this.elementIsInView(element)) {\r\n\t\t\t\tthis.animateElements([element]);\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\t/** Main Element Count Animation */\r\n\tanimateElements(elements, observer) {\r\n\t\telements.forEach(element => {\r\n\t\t\tlet elm = element.target || element; // Just make sure which element will be used\r\n\t\t\tlet elementConfig = this.parseConfig(elm); // Get config value on that element\r\n\t\t\t// Deconstruct config value and create it variable\r\n\t\t\tlet {start, end, duration, delay} = elementConfig;\r\n\t\t\t// If duration is less than or equal zero, just format the 'end' value\r\n\t\t\tif (duration <= 0) {\r\n\t\t\t\treturn elm.innerHTML = this.formatNumber(end, elementConfig);\r\n\t\t\t}\r\n\r\n\t\t\tif ((!observer && !this.elementIsInView(element)) || (observer && element.intersectionRatio < 0.5)) {\r\n\t\t\t\tlet value = start > end ? end : start;\r\n\t\t\t\treturn elm.innerHTML = this.formatNumber(value, elementConfig);\r\n\t\t\t}\r\n\r\n\t\t\t// If duration is more than 0, then start the counter\r\n\t\t\tsetTimeout(() => {\r\n\t\t\t\treturn this.startCounter(elm, elementConfig);\r\n\t\t\t}, delay);\r\n\t\t});\r\n\t}\r\n\r\n\t/** This is the the counter method */\r\n\tstartCounter(element, config) {\r\n\t\t// Deconstruct config value and create it variable\r\n\t\tlet {start, end, duration, delay, once, repeat} = config;\r\n\t\t// First, get the increments step\r\n\t\tlet incrementsPerStep = (end - start) / (duration / delay);\r\n\t\t// Next, set the counter mode (Increment or Decrement)\r\n\t\tlet countMode = 'inc';\r\n\r\n\t\t// Set mode to 'decrement' and 'increment step' to minus if start is larger than end\r\n\t\tif (start > end) {\r\n\t\t\tcountMode = 'dec';\r\n\t\t\tincrementsPerStep *= -1;\r\n\t\t}\r\n\r\n\t\t// Next, determine the starting value\r\n\t\tlet currentCount = this.parseValue(start);\r\n\t\t// And then print it's value to the page\r\n\t\telement.innerHTML = this.formatNumber(currentCount, config);\r\n\r\n\t\t// If the config 'once' is true, then set the 'duration' to 0\r\n\t\tif(once === true){\r\n\t\t\telement.setAttribute('data-purecounter-duration', 0);\r\n\t\t}\r\n\r\n\t\t// Now, start counting with counterWorker using Interval method based on delay\r\n\t\tlet counterWorker = setInterval(() => {\r\n\t\t\t// First, determine the next value base on current value, increment value, and count mode\r\n\t\t\tvar nextNum = this.nextNumber(currentCount, incrementsPerStep, countMode);\r\n\t\t\t// Next, print that value to the page\r\n\t\t\telement.innerHTML = this.formatNumber(nextNum, config);\r\n\t\t\t// Now set that value to the current value, because it's already printed\r\n\t\t\tcurrentCount = nextNum;\r\n\r\n\t\t\t// If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\r\n\t\t\tif ((currentCount >= end && countMode == 'inc') || (currentCount <= end && countMode == 'dec')) {\r\n\t\t\t\telement.innerHTML = this.formatNumber(end, config);\r\n\t\t\t\t// If 'once' is false and 'repeat' is set\r\n\t\t\t\tif(!once && repeat){\r\n\t\t\t\t\t// First set the 'duration' to zero\r\n\t\t\t\t\telement.setAttribute('data-purecounter-duration', 0);\r\n\t\t\t\t\t// Next, use timeout to reset it duration back based on 'repeat' config\r\n\t\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t\telement.setAttribute('data-purecounter-duration', (duration / 1000));\r\n\t\t\t\t\t}, repeat);\r\n\t\t\t\t}\r\n\t\t\t\t// Now, we can close the conterWorker peacefully\r\n\t\t\t\tclearInterval(counterWorker);\r\n\t\t\t}\r\n\t\t}, delay);\r\n\t}\r\n\r\n\t/** This function is to generate the element Config */\r\n\tparseConfig(element) {\r\n\t\t// First, we need to declare the base Config\r\n\t\t// This config will be used if the element doesn't have config\r\n\t\tlet baseConfig = {...this.configOptions};\r\n\r\n\t\t// Next, get all 'data-precounter-*' attributes value. Store to array\r\n\t\tlet configValues = [].filter.call(element.attributes, function(attr) {\r\n\t\t\treturn /^data-purecounter-/.test(attr.name);\r\n\t\t});\r\n\r\n\t\t// Now, we create element config as an object\r\n\t\tlet elementConfig = configValues.length != 0 ? Object.assign({}, ...configValues.map(({name, value}) => {\r\n\t\t\tlet key = name.replace('data-purecounter-', '').toLowerCase(),\r\n\t\t\t\tval = this.parseValue(value);\r\n\r\n\t\t\treturn {[key] : val};\r\n\t\t})) : {};\r\n\r\n\t\t// Last setOptions and return\r\n\t\treturn this.setOptions(elementConfig, baseConfig);\r\n\t}\r\n\r\n\t/** This function is to get the next number */\r\n\tnextNumber(number, steps, mode = 'inc') {\r\n\t\t// First, get the exact value from the number and step (int or float)\r\n\t\tnumber = this.parseValue(number);\r\n\t\tsteps = this.parseValue(steps);\r\n\r\n\t\t// Last, get the next number based on current number, increment step, and count mode\r\n\t\t// Always return it as float\r\n\t\treturn parseFloat(mode === 'inc' ? (number + steps) : (number - steps));\r\n\t}\r\n\r\n\t/** This function is to get the converted number */\r\n\tconvertNumber (number, config) {\r\n\t\t// Deconstruct config value and create it variable\r\n\t\tlet {currency, filesizing} = config;\r\n\t\t/** Use converter if filesizing or currency is on */\r\n\t\tif (filesizing || currency) {\r\n\t\t\tnumber = Math.abs(Number(number)); // Get the absolute value of number\r\n\r\n\t\t\tlet baseNumber = 1000, // Base multiplying treshold\r\n\t\t\t\tsymbol = currency && typeof currency === 'string' ? currency : \"\", // Set the Currency Symbol (if any)\r\n\t\t\t\tlimit = config.decimals || 1, // Set the decimal limit (default is 1)\r\n\t\t\t\tunit = ['', 'K', 'M', 'B', 'T'], // Number unit based exponent threshold\r\n\t\t\t\tvalue = ''; // Define value variable\r\n\r\n\t\t\t/** Changes base number and its unit for filesizing */\r\n\t\t\tif (filesizing) {\r\n\t\t\t\tbaseNumber = 1024; // Use 1024 instead of 1000\r\n\t\t\t\tunit = ['bytes', 'KB', 'MB', 'GB', 'TB']; // Change to 'bytes' unit\r\n\t\t\t}\t\t\r\n\r\n\t\t\t/** Get threshold value using exponent from basenumber */\r\n\t\t\tconst threshold = e => Math.pow(baseNumber, e);\r\n\r\n\t\t\t/** Set value based on the threshold */\r\n\t\t\tfor(let i = 4; i >= 0; i--){\r\n\t\t\t\t// If the exponent is 0\r\n\t\t\t\tif(i === 0) value = `${number.toFixed(limit)} ${unit[i]}`;\r\n\t\t\t\t// If the exponent is above zero\r\n\t\t\t\tif(number >= threshold(i)) {\r\n\t\t\t\t\tvalue = `${(number / threshold(i)).toFixed(limit)} ${unit[i]}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Apply symbol before the value and return it as string\r\n\t\t\treturn symbol + value;\r\n\t\t} else {\r\n\t\t\t/** Return its value as float if not using filesizing or currency*/\r\n\t\t\treturn parseFloat(number);\r\n\t\t}\r\n\t}\r\n\r\n\t/** This function is to get the last formated number */\r\n\tapplySeparator(value, config){\r\n\t\t// Deconstruct config value\r\n\t\tlet {separator} = config;\r\n\t\t// If config separator is false, delete all separator\r\n\t\tif (!separator) {\r\n\t\t\treturn value.replace(new RegExp(/,/gi, 'gi'), '')\r\n\t\t}\r\n\t\t// Set the separator symbol.\r\n\t\t// If 'separator' is string, than use the separator.\r\n\t\t// If 'separator' is boolean value for 'true', just set it default to comma (,)\r\n\t\tlet symbol = typeof separator === 'string' ? separator : ',';\r\n\t\t// If config separator is true, then create separator\r\n\t\treturn value.replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1,\")\r\n\t\t\t.replace(new RegExp(/,/gi, 'gi'), symbol)\r\n\t}\r\n\r\n\t/** This function is to get formated number to be printed in the page */\r\n\tformatNumber(number, config) {\r\n\t\tlet {decimals} = config;\r\n\t\t// This is the configuration for 'toLocaleString' method\r\n\t\tlet strConfig = {minimumFractionDigits: decimals, maximumFractionDigits: decimals};\r\n\t\t// Set and convert the number base on its config.\r\n\t\tnumber = this.convertNumber(number, config);\r\n\r\n\t\t// Last, apply the number separator using number as string\r\n\t\treturn this.applySeparator(number.toLocaleString(undefined, strConfig), config);\r\n\t}\r\n\r\n\t/** This function is to get the parsed value */\r\n\tparseValue(data) {\r\n\t\t// If number with dot (.), will be parsed as float\r\n\t\tif (/^[0-9]+\\.[0-9]+$/.test(data)) {\r\n\t\t\treturn parseFloat(data);\r\n\t\t}\r\n\t\t// If just number, will be parsed as integer\r\n\t\tif (/^[0-9]+$/.test(data)) {\r\n\t\t\treturn parseInt(data);\r\n\t\t}\r\n\t\t// If it's boolean string, will be parsed as boolean\r\n\t\tif (/^true|false/i.test(data)) {\r\n\t\t\treturn /^true/i.test(data);\r\n\t\t}\r\n\t\t// Return it's value as default\r\n\t\treturn data;\r\n\t}\r\n\r\n\t/** This function is to detect the element is in view or not. */\r\n\telementIsInView(element) {\r\n\t\tvar top = element.offsetTop;\r\n\t\tvar left = element.offsetLeft;\r\n\t\tvar width = element.offsetWidth;\r\n\t\tvar height = element.offsetHeight;\r\n\r\n\t\twhile (element.offsetParent) {\r\n\t\t\telement = element.offsetParent;\r\n\t\t\ttop += element.offsetTop;\r\n\t\t\tleft += element.offsetLeft;\r\n\t\t}\r\n\r\n\t\treturn (\r\n\t\t\ttop >= window.pageYOffset &&\r\n\t\t\tleft >= window.pageXOffset &&\r\n\t\t\t(top + height) <= (window.pageYOffset + window.innerHeight) &&\r\n\t\t\t(left + width) <= (window.pageXOffset + window.innerWidth)\r\n\t\t);\r\n\t}\r\n\r\n\t/** Just some condition to check browser Intersection Support */\r\n\tintersectionListenerSupported() {\r\n\t\treturn ('IntersectionObserver' in window) &&\r\n\t\t\t('IntersectionObserverEntry' in window) &&\r\n\t\t\t('intersectionRatio' in window.IntersectionObserverEntry.prototype);\r\n\t}\r\n}","// require PureCounter from './js/purecounter.js';\r\n// Store it as consant\r\nconst PureCounter = require('./js/purecounter').default;\r\n\r\n// Set module Export to PureCounter class, so it can be initialize as class\r\nmodule.exports = PureCounter;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(634);\n"],"names":["root","factory","exports","module","define","amd","self","PureCounter","options","this","defaults","start","end","duration","delay","once","repeat","decimals","legacy","filesizing","currency","separator","selector","configOptions","setOptions","elements","document","querySelectorAll","intersectionSupport","intersectionListenerSupported","registerEventListeners","config","baseConfig","newConfig","key","hasOwnProperty","val","parseValue","match","Object","assign","length","intersectObserver","IntersectionObserver","animateElements","bind","forEach","element","observe","window","addEventListener","animateLegacy","e","parseConfig","elementIsInView","observer","elm","target","elementConfig","innerHTML","formatNumber","intersectionRatio","value","setTimeout","startCounter","incrementsPerStep","countMode","currentCount","setAttribute","counterWorker","setInterval","nextNum","nextNumber","clearInterval","configValues","filter","call","attributes","attr","test","name","map","replace","toLowerCase","number","steps","mode","parseFloat","Math","abs","Number","baseNumber","symbol","limit","unit","threshold","pow","i","toFixed","RegExp","strConfig","minimumFractionDigits","maximumFractionDigits","convertNumber","applySeparator","toLocaleString","undefined","data","parseInt","top","offsetTop","left","offsetLeft","width","offsetWidth","height","offsetHeight","offsetParent","pageYOffset","pageXOffset","innerHeight","innerWidth","IntersectionObserverEntry","prototype","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","obj","prop"],"sourceRoot":""}